# CHWIMEET

<div align="center">
<img width="500" height="440" alt="취밋로고" src="https://github.com/user-attachments/assets/e9b2a843-b5a8-44ec-adbf-03d8adf6a775" />

  <p> <strong>취밋</strong>은 일상에서 잠깐 필요한 물건을<br />
    가까운 사람들과 쉽게 빌리고 빌려줄 수 있는 P2P 대여 플랫폼입니다.<br /> 
    사기 힘들고, 보관이 번거롭고, 오래 쓰지 않는 물건들을<br /> 
    필요한 순간에만 편하게 이용할 수 있도록 돕습니다.<br /> 
    사용자는 서로의 물건을 공유하며 비용을 절약하고,<br /> 
    동네에서 자연스러운 나눔과 연결이 이어지는 경험을 제공합니다. 
  </p>
</div>

<br>

# 📖 목차
1. [💡 개발 배경](#-개발-배경)
2. [🧩 아키텍쳐](#-아키텍쳐)
3. [🚀 기능 소개](#-기능-소개)
4. [🛠️ 기술 스택](#️-기술-스택)
5. [⚙️ 기능 구현 방식](#️-기능-구현-방식)
6. [🔥 트러블슈팅](#-트러블-슈팅)

<br>

# 💡 개발 배경

우리 주변에는 한두 번만 사용하고 방치되는 물건들이 정말 많습니다.  
캠핑 장비, 공구, 촬영 장비처럼 **자주 쓰지 않지만 필요할 때는 꼭 필요한 물건들**이 대표적입니다.  
이런 물건들을 사기에는 부담되고, 보관도 번거롭고, 그렇다고 한 번 쓰자고 구매하기도 아깝습니다.

그래서 많은 사람들은 친구나 지인에게 빌리려고 해보지만,  
**누가 어떤 물건을 가지고 있는지 알기 어렵고**,  
빌리고 돌려주는 과정에서도 생각보다 많은 불편이 생깁니다.

**“잠깐만 필요한 물건, 이웃에게 편하게 빌릴 수 있다면 어떨까?”**  
**“서랍 속에 놀고 있는 물건들을, 필요한 사람들에게 자연스럽게 공유할 수는 없을까?”**

만약 그런 환경이 마련된다면, 물건을 둘러싼 소비는 훨씬 더 가볍고 효율적이 될 것입니다.  
구매 부담은 줄고, 집 안에 쌓여가는 물건도 줄어들며,  
이웃 간의 연결과 신뢰가 자연스럽게 생겨나는 경험도 가능해집니다.

저희는 많은 사람들이 일상 속에서 느끼는 이 **작지만 반복적인 불편함과 아쉬움**을 기술로 해결해보고자,  
이 P2P 물건 대여 플랫폼을 기획하게 되었습니다.


<br>

# 🧩 아키텍쳐
- 아키텍처 이미지
<div align="center">
<img width="720" height="347" alt="image" src="https://github.com/user-attachments/assets/fa9ea756-b7c3-4f40-b0f0-812108882554" />
</div>

### 주요 아키텍처 특징
  - **실시간 모니터링**: Grafana 대시보드를 통한 실시간 시스템 메트릭 모니터링 및 알림
  - **무중단 배포**: Nginx Proxy Manager를 활용한 Blue/Green 배포 전략으로 서비스 중단 없이 안전한 배포 구현
  - **이미지 최적화**: AWS Lambda를 통한 서버리스 이미지 리사이징으로 메인 서버 부하 분산 및 비용 효율화
  - **분산 캐싱**: Redis를 활용한 세션 관리 및 캐싱으로 서버 간 데이터 일관성 유지

<br>

# 🚀 기능 소개

## 1️⃣ RAG 기반 스마트 검색
Spring AI와 MariaDB Vector Store를 활용한 의미 기반 검색 시스템
- OpenAI Embedding API를 통한 텍스트 벡터화
- 코사인 유사도 기반 연관 콘텐츠 검색

## 2️⃣ 실시간 채팅 및 알림
Redis Pub/Sub과 WebSocket을 결합한 확장 가능한 실시간 통신
- Redis Pub/Sub을 통한 서버 간 메시지 브로드캐스팅
- STOMP 프로토콜 기반 양방향 실시간 통신
- 채팅방별 독립적인 메시지 스트림 관리

## 3️⃣ Quartz 기반 배치 작업
스케줄링 기반 자동화 작업 처리
- 만료된 데이터 정리 및 임베딩 생성 자동화
- 버저닝, 낙관적 락 등을 활용한 동시성 제어 처리

<br>

# 🛠️ 기술 스택

- 아이콘이나 이미지로 기술 스택 나열 후 특별히 선택한 이유가 명확하고 눈에 뛸만한 기술 스택에 대해 선택한 이유 적기

## 💡 주요 기술 선택 이유
### MariaDB - 벡터 검색을 지원하는 관계형 데이터베이스

**선택 배경**

프로젝트 초기에는 익숙한 관계형 데이터베이스인 MySQL을 사용했지만, 검색 정확도 향상과 임베딩 기반 분류 기능을 구현하기 위해 `벡터 검색(Vector Search)`이 필요한 상황이 되었습니다.

**대안 검토**

외부 Vector Database(Pinecone, Qdrant, Weaviate 등)도 검토했으나, 별도의 솔루션을 도입할 경우 다음과 같은 문제가 예상되었습니다:

- 운영 복잡성 증가
- 관계형 데이터와의 동기화 이슈
- 추가 인프라 비용 발생

**MariaDB의 장점**

- **통합 데이터 관리**: 벡터 타입과 벡터 인덱스를 공식 지원하여 관계형 데이터와 벡터 데이터를 단일 DB에서 관리
- **인프라 단순화**: 추가 데이터베이스 없이 기존 MySQL 계열의 장점 유지하면서 벡터 검색 기능 확장
- **데이터 일관성**: 트랜잭션 내에서 일반 데이터와 임베딩 데이터를 함께 처리하여 정합성 보장
- **Spring AI 통합**: MariaDB Vector Store를 기본 지원하여 복잡한 커넥터 구현 없이 Spring Data 스타일로 즉시 사용 가능

이를 통해 개발 속도와 유지보수성을 크게 향상시키면서도 운영 복잡도는 최소화할 수 있었습니다.

### Quartz - 안정적인 배치 작업 스케줄링

**선택 배경**

프로젝트에서는 게시글의 주기적인 임베딩 처리와 일정 기간이 지난 데이터의 정리 작업이 필요했습니다. Spring Boot의 `@Scheduled` 어노테이션으로도 구현 가능했지만, 서비스 확장을 고려했을 때 몇 가지 한계가 있었습니다.

**@Scheduled의 한계**

- **단일 인스턴스 전제**: 여러 서버 인스턴스가 동시에 실행되면 동일한 배치 작업이 중복 실행됨
- **동적 관리 불가**: 실행 중인 작업의 수정이나 일시 중지가 어려움
- **실행 이력 부재**: 작업 성공/실패 여부를 추적하기 위해 별도의 로깅 시스템 구축 필요

**Quartz의 장점**

Quartz는 이러한 문제들을 해결할 수 있는 엔터프라이즈급 스케줄러입니다:

- **클러스터 모드 지원**: 데이터베이스 기반의 분산 락을 통해 다중 서버 환경에서도 작업이 한 번만 실행되도록 보장
- **동적 스케줄 관리**: 런타임에 작업 추가/수정/삭제가 가능하여 서버 재시작 없이 배치 전략 변경 가능
- **실행 이력 관리**: 작업의 실행 시간, 성공/실패 여부 등을 데이터베이스에 자동 저장
- **유연한 트리거**: Cron 표현식뿐만 아니라 다양한 실행 조건 설정 가능

특히 Blue/Green 배포 환경에서 두 인스턴스가 동시에 실행되는 순간에도 배치 작업의 중복 실행을 방지할 수 있다는 점이 결정적이었습니다.

<br>

# ⚙️ 기능 구현 방식

## Quartz 기반 배치 작업 - 게시글 임베딩 처리

### 구현 배경

게시글 작성 시 즉시 임베딩하면 OpenAI API 호출로 3~5초 지연이 발생합니다. 이를 해결하기 위해 게시글 작성은 즉시 완료하고, 임베딩은 백그라운드에서 주기적으로 처리하도록 설계했습니다.

### 핵심 과제: 다중 워커 환경에서의 중복 처리 방지

Quartz는 **배치 작업 자체의 중복 실행**은 방지하지만, **동일한 데이터를 여러 워커가 처리하는 것**은 막을 수 없습니다. 이를 해결하기 위해 버저닝 및 상태 기반 선점(Claim) 패턴을 적용했습니다.


### 상태 기반 선점 로직

**1. 상태 관리**
- 게시글(Post) 엔티티에 `embeddingVersion` 필드 추가
```java
@Version
@Column(name = "embedding_version", nullable = false)
private Long embeddingVersion;
```
- 게시글 임베딩 상태를 나타내는 `EmbeddingStatus` 열거형 정의
```java
public enum EmbeddingStatus {
    WAIT,     // 임베딩 대기
    PENDING,  // 처리 중 (워커가 선점)
    DONE      // 완료
}
```

**2. 배치 처리 로직**
- Quartz 배치 작업에서 다음과 같은 순서로 처리
  1. `WHERE embeddingStatus = WAIT` 조건으로 아직 처리되지 않은 게시글을 선점(`WAIT → PENDING`) 이때 `embeddingVersion`도 함께 증가
  2. 선점된 게시글 중 실제로 `PENDING` 상태이며 `embeddingVersion`이 일치하는 게시글만 처리
  3. 임베딩 성공 시 `PENDING → DONE`, 실패 시 `PENDING → WAIT`로 상태 업데이트
  4. 다음 배치에서 다시 처리


### 핵심 메커니즘

**동시성 제어**
- `WHERE embeddingStatus = WAIT` 조건과 `embeddingVersion`으로 아직 처리되지 않은 게시글만 선점
- 여러 워커가 동시에 업데이트를 시도해도 DB 레벨에서 하나의 워커만 성공
- 선점 후 실제로 PENDING 상태인 게시글만 처리하여 이중 안전장치

**실패 복구**
- 임베딩 실패 시 `PENDING → WAIT`로 복원하여 다음 배치에서 자동 재시도
- 작업 성공 시 `PENDING → DONE`으로 완료 처리

### 장점

✅ **중복 처리 방지**: DB 조건문으로 동일 데이터를 여러 워커가 처리하지 않음  
✅ **자동 재시도**: 실패한 작업은 자동으로 다음 배치에서 재처리  
✅ **확장 가능**: 워커 수를 늘려도 코드 수정 없이 분산 처리  

<br>

# 🔥 트러블 슈팅

- 적어놓은 트러블 슈팅들 중, 기술적으로 설명할 내용이 많거나, 어필할만한 내용을 구체적(문제 발생, 원인 파악, 원인, 해결 및 과정)으로 정리하면 좋을 것 같음.
