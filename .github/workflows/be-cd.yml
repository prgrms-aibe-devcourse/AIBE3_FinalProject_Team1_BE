name: be-cd

on:
  push:
    branches: ["main"]
    paths:
      - "backend/src/**"
      - "backend/build.gradle.kts"
      - "backend/Dockerfile"
      - ".github/workflows/be-cd.yml"

permissions:
  contents: read
  packages: write

concurrency:
  group: be-cd-${{ github.ref }}
  cancel-in-progress: false # Î∞∞Ìè¨Îäî Ï∑®ÏÜåÌïòÏßÄ ÏïäÏùå

env:
  REGISTRY: ghcr.io
  # ‚ú® [ÏàòÏ†ï] IMAGE_NAME Ï†ïÏùòÎ•º Ï†úÍ±∞ÌñàÏäµÎãàÎã§. JOB ÎÇ¥Î∂ÄÏóêÏÑú ÎèôÏ†ÅÏúºÎ°ú ÏÑ§Ï†ïÎê©ÎãàÎã§.

defaults:
  run:
    working-directory: backend

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ‚ú® [ÏàòÏ†ï] Ïù¥ Îã®Í≥ÑÏóêÏÑú OWNER_LCÎ•º ÏÑ§Ï†ïÌïòÍ≥†, IMAGE_NAMEÏùÑ Ï¶âÏãú ÏÑ§Ï†ïÌï©ÎãàÎã§.
      - name: Set owner name and image name
        run: |
          # 1. OWNER_LC ÏÑ§Ï†ï (ÏÜåÎ¨∏ÏûêÌôî)
          OWNER_LC=${{ github.repository_owner }}
          OWNER_LC=${OWNER_LC,,} 
          echo "OWNER_LC=$OWNER_LC" >> $GITHUB_ENV

          # 2. IMAGE_NAME ÏÑ§Ï†ï (GHCR Í∑úÏπôÏóê ÎßûÍ≤å ÏÜåÎ¨∏Ïûê ÏÜåÏú†Ïûê Ïù¥Î¶Ñ ÏÇ¨Ïö©)
          IMAGE_NAME="$OWNER_LC/chwimeet-backend"
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      # gradle wrapper Î≥¥Ïïà Í≤ÄÏ¶ù
      - name: Validate Gradle Wrapper
        uses: gradle/wrapper-validation-action@v2
        with:
          gradle-wrapper-path: backend/gradle/wrapper/gradle-wrapper.jar

      # Gradle Ïã§Ìñâ JVM(JDK 24)
      - name: Setup Java (Gradle JVM = 24)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "24"
          cache: gradle
          cache-dependency-path: backend/build.gradle.kts

      # ÏΩîÎìú toolchainÏö© JDK 25 ÎØ∏Î¶¨ ÏÑ§Ïπò
      - name: Provision Java 25 for toolchain
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "25"

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3
        with:
          gradle-version: wrapper
          build-root-directory: backend

      - name: Make gradlew executable
        run: chmod +x ./gradlew

      # ÎπåÎìú (ÌÖåÏä§Ìä∏ Ï†úÏô∏ - CIÏóêÏÑú Ïù¥ÎØ∏ ÌÖåÏä§Ìä∏ ÏôÑÎ£å)
      - name: Build with Gradle
        run: ./gradlew clean bootJar -x test --no-daemon

      # Docker Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          # ‚ú® ÏàòÏ†ï: env.IMAGE_NAMEÏù¥ StepÏóêÏÑú ÏÑ§Ï†ïÎêòÏóàÏúºÎØÄÎ°ú Ïù¥Ï†ú Ï†ëÍ∑º Í∞ÄÎä•
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      # GHCR Î°úÍ∑∏Ïù∏
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Docker Ïù¥ÎØ∏ÏßÄ ÎπåÎìú Î∞è Push
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # cache-fromÍ≥º cache-toÎäî Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

      - name: Image digest
        run: echo "üê≥ Pushed image - ${{ steps.meta.outputs.tags }}"

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    timeout-minutes: 15

    # üî• Ïó¨Í∏∞ÏÑú build-and-pushÏùò backend ÎîîÎ†âÌÜ†Î¶¨ Í∏∞Î≥∏Í∞íÏùÑ ÎçÆÏñ¥ÏîÄ
    defaults:
      run:
        working-directory: .   # Î£®Ìä∏ÏóêÏÑú Ïã§Ìñâ

    environment:
      name: production
      url: https://${{ vars.APP_DOMAIN }}

    steps:
      # (ÏÑ†ÌÉù) ÏΩîÎìúÍ∞Ä ÌïÑÏöî ÏóÜÏúºÎ©¥ checkoutÏùÄ ÏÉùÎûµÌï¥ÎèÑ Îê®
      # - name: Checkout
      #   uses: actions/checkout@v4

      # 1. AWS ÏûêÍ≤© Íµ¨ÏÑ±
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ secrets.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # 2. Name ÌÉúÍ∑∏Î°ú EC2 Ïù∏Ïä§ÌÑ¥Ïä§ Ï°∞Ìöå
      - name: Get Instance ID
        id: get_instance_id
        env:
          EC2_INSTANCE_TAG_NAME: team1-backend
        run: |
          set -e
          
          echo "üîç Finding EC2 instance with tag Name=${EC2_INSTANCE_TAG_NAME}"
          
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${EC2_INSTANCE_TAG_NAME}" \
                      "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text)
          
          # ‚úÖ Ïó¨Í∏∞ÏÑú ÏïàÏ†ÑÌïòÍ≤å Í≤ÄÏ¶ù (Í¥ÑÌò∏/Î≥µÏû°Ìïú Î¨∏Î≤ï ÏóÜÏù¥)
          if [ -z "${INSTANCE_ID}" ] || [ "${INSTANCE_ID}" = "None" ]; then
            echo "‚ùå No running instance found"
            exit 1
          fi
          
          echo "‚úÖ Found instance: ${INSTANCE_ID}"
          echo "INSTANCE_ID=${INSTANCE_ID}" >> "${GITHUB_ENV}"

      # ========================================
      # ÏôÑÏ†Ñ ÏûêÎèôÌôîÎêú Blue-Green Î∞∞Ìè¨
      # EC2Ïùò Í∏∞Ï°¥ deploy.sh Ïä§ÌÅ¨Î¶ΩÌä∏ ÌôúÏö©
      # ========================================
      - name: Fully Automated Blue-Green Deployment
        id: deploy
        run: |
          set -e

          echo "=========================================="
          echo "üöÄ Starting Fully Automated Blue-Green Deployment"
          echo "=========================================="

          echo "Target instance: $INSTANCE_ID"

          # SSMÏùÑ ÌÜµÌï¥ Î∞∞Ìè¨ Ïä§ÌÅ¨Î¶ΩÌä∏ Ïã§Ìñâ
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Fully automated Blue-Green deployment" \
            --timeout-seconds 600 \
            --parameters 'commands=[
              "set -e",
              "cd /home/ec2-user/app",
              "bash /home/ec2-user/app/deploy.sh"
            ]' \
            --query 'Command.CommandId' \
            --output text)

          echo "üì§ Command ID: ${COMMAND_ID}"
          echo "COMMAND_ID=${COMMAND_ID}" >> "${GITHUB_ENV}"

          echo "‚è≥ Waiting for deployment to complete..."

          MAX_WAIT=600
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "${COMMAND_ID}" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text)

            echo "Status: ${STATUS} (${ELAPSED}s elapsed)"

            if [ "${STATUS}" = "Success" ]; then
              echo "‚úÖ Deployment completed successfully!"
              break
            elif [ "${STATUS}" = "Failed" ] || [ "${STATUS}" = "Cancelled" ] || [ "${STATUS}" = "TimedOut" ]; then
              echo "‚ùå Deployment failed with status: ${STATUS}"
              exit 1
            fi

            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done

          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "‚ùå Deployment timed out"
            exit 1
          fi

      - name: Get Deployment Logs
        if: always()
        run: |
          echo "=========================================="
          echo "üìã Deployment Logs"
          echo "=========================================="
          
          aws ssm get-command-invocation \
            --command-id ${{ env.COMMAND_ID }} \
            --instance-id ${{ env.INSTANCE_ID }} \
            --query 'StandardOutputContent' \
            --output text
          
          ERROR_OUTPUT=$(aws ssm get-command-invocation \
            --command-id ${{ env.COMMAND_ID }} \
            --instance-id ${{ env.INSTANCE_ID }} \
            --query 'StandardErrorContent' \
            --output text)
          
          if [ ! -z "$ERROR_OUTPUT" ]; then
            echo "=========================================="
            echo "‚ö†Ô∏è  Error Output"
            echo "=========================================="
            echo "$ERROR_OUTPUT"
          fi

      - name: Deployment Summary
        if: success()
        run: |
          echo "=========================================="
          echo "üéâ Deployment Summary"
          echo "=========================================="
          echo "‚úÖ Blue-Green deployment completed"
          echo "üì¶ Image: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "üñ•Ô∏è  Instance: ${{ env.INSTANCE_ID }}"
          echo "üåê URL: https://${{ vars.APP_DOMAIN }}"
          echo ""
          echo "‚ö†Ô∏è  Manual Steps Required:"
          echo "1. Login to Nginx Proxy Manager (http://your-ip:81)"
          echo "2. Update Forward Hostname/IP to new container"
          echo "3. SSH and remove old container:"
          echo "   docker-compose stop [old-container]"
          echo "   docker-compose rm -f [old-container]"
          echo "=========================================="

      - name: Deployment Failed
        if: failure()
        run: |
          echo "=========================================="
          echo "‚ùå Deployment Failed"
          echo "=========================================="
          echo "Please check the deployment logs above"
          echo "The old container is still running (safe state)"
          echo "=========================================="